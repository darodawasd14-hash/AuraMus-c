{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user of the Aura application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the User entity."
        },
        "name": {
          "type": "string",
          "description": "The user's name."
        },
        "email": {
          "type": "string",
          "description": "The user's email address.",
          "format": "email"
        }
      },
      "required": [
        "id",
        "name",
        "email"
      ]
    },
    "Song": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Song",
      "type": "object",
      "description": "Represents a song in the user's music library.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Song entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Song)"
        },
        "title": {
          "type": "string",
          "description": "The title of the song."
        },
        "artist": {
          "type": "string",
          "description": "The artist of the song."
        },
        "album": {
          "type": "string",
          "description": "The album the song belongs to."
        },
        "filePath": {
          "type": "string",
          "description": "The file path to the song."
        }
      },
      "required": [
        "id",
        "userId",
        "title",
        "artist",
        "album",
        "filePath"
      ]
    },
    "Playlist": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Playlist",
      "type": "object",
      "description": "Represents a playlist created by the user.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Playlist entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Playlist)"
        },
        "name": {
          "type": "string",
          "description": "The name of the playlist."
        },
        "songIds": {
          "type": "array",
          "description": "References to Songs. (Relationship: Playlist N:N Song)",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "userId",
        "name",
        "songIds"
      ]
    },
    "SmartPlaylist": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "SmartPlaylist",
      "type": "object",
      "description": "Represents a smart playlist generated by the AI based on user's listening habits.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the SmartPlaylist entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N SmartPlaylist)"
        },
        "name": {
          "type": "string",
          "description": "The name of the smart playlist."
        },
        "songIds": {
          "type": "array",
          "description": "References to Songs. (Relationship: SmartPlaylist N:N Song)",
          "items": {
            "type": "string"
          }
        },
        "criteria": {
          "type": "string",
          "description": "The criteria used to generate the playlist (e.g., mood, genre)."
        }
      },
      "required": [
        "id",
        "userId",
        "name",
        "songIds",
        "criteria"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profile information. Path-based ownership.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user, matching their Firebase Auth UID."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/songs/{songId}",
        "definition": {
          "entityName": "Song",
          "schema": {
            "$ref": "#/backend/entities/Song"
          },
          "description": "Stores songs owned by a specific user. Path-based ownership.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user who owns the song."
            },
            {
              "name": "songId",
              "description": "The unique identifier for the song."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/playlists/{playlistId}",
        "definition": {
          "entityName": "Playlist",
          "schema": {
            "$ref": "#/backend/entities/Playlist"
          },
          "description": "Stores playlists created by a specific user. Path-based ownership.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user who created the playlist."
            },
            {
              "name": "playlistId",
              "description": "The unique identifier for the playlist."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/smartPlaylists/{smartPlaylistId}",
        "definition": {
          "entityName": "SmartPlaylist",
          "schema": {
            "$ref": "#/backend/entities/SmartPlaylist"
          },
          "description": "Stores smart playlists generated for a specific user. Path-based ownership.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user the smart playlist is generated for."
            },
            {
              "name": "smartPlaylistId",
              "description": "The unique identifier for the smart playlist."
            }
          ]
        }
      },
      {
        "path": "/roles_admin/{userId}",
        "definition": {
          "entityName": "admin",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Indicates admin role for a user. Document existence grants admin privileges.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user with admin privileges."
            }
          ]
        }
      }
    ],
    "reasoning": "The error indicates a permission issue when trying to `get` the document at `/admins/{userId}`. This suggests the application is attempting to check if the current user is an admin by reading their document in the `admins` collection. To resolve this, we should use a dedicated collection for admin roles and structure the data to ensure authorization independence and efficient QAPs (Queries are not filters). Also, based on the core principles, roles must be stored in the database and authorization should rely solely on `request.auth.uid`. Path-Based ownership is used for user related data.\n\nHere's how the data structure addresses the core design principles:\n\n*   **Authorization Independence:** The `/roles_admin/{userId}` collection directly indicates admin status based on document existence, eliminating the need for `get()` calls to other documents and maintaining atomic operation capabilities.\n*   **Clarity of Intent:** The existence of a document in `/roles_admin/{userId}` clearly signifies admin status.\n*   **DBAC (No Custom Claims):** Admin roles are stored directly in the database.\n*   **QAPs (Rules are not Filters):** The structure allows secure `list` operations by directly querying the `roles_admin` collection (if needed, though listing all admins should be rare).\n*   **Invariants:** User ownership is enforced using path-based ownership for user-specific data like songs and playlists.\n\nBased on the application requirements, the following structure is recommended, focusing on path-based ownership for user data and a dedicated collection for admin roles:"
  }
}