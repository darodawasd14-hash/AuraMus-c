/**
 * @fileoverview Firestore Security Rules for Aura application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user profiles and playlists.
 * Users can only read and write their own profile data and playlists. Public read access is granted for the /songs collection.
 *
 * Data Structure:
 * - /users/{userId}: User profile information.
 * - /users/{userId}/playlists/{playlistId}: User-created playlists.
 * - /users/{userId}/playlists/{playlistId}/songs/{songId}: Songs within a user's playlist.
 * - /songs/{songId}: A global catalog of songs, publicly readable.
 * - /songs/{songId}/messages/{messageId}: Chat messages for specific songs.
 *
 * Key Security Decisions:
 * - Users can only manage their own playlists and songs within those playlists.
 * - The global song catalog (/songs/{songId}) is publicly readable but write-protected, write operations are allowed if the song doesn't exist yet and the creatorId is the authenticated user.
 * - User listing is disallowed.
 * - Anyone can read the chat messages for songs.
 *
 * Denormalization for Authorization:
 * - Playlists have a `userId` field to enforce ownership and avoid `get()` calls.
 * - Songs in the global catalog have a `creatorId` field, write operations are allowed if the song doesn't exist yet and the creatorId is the authenticated user.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description: Secure user profiles. Only the owner can read and write their profile.
     * @path: /users/{userId}
     * @allow: User with UID 'user123' (create) can create their own profile document at /users/user123.
     * @deny: User with UID 'user456' (get) cannot read the profile document at /users/user123.
     * @principle: Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description: Secure user playlists. Only the owner can read, create, update, and delete their playlists.
     * @path: /users/{userId}/playlists/{playlistId}
     * @allow: User with UID 'user123' (create) can create a playlist at /users/user123/playlists/playlist1.
     * @deny: User with UID 'user456' (update) cannot update the playlist at /users/user123/playlists/playlist1.
     * @principle: Enforces document ownership for writes and reads.
     */
    match /users/{userId}/playlists/{playlistId} {
       function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description: Secure songs within a user's playlist. Only the playlist owner can manage songs.
     * @path: /users/{userId}/playlists/{playlistId}/songs/{songId}
     * @allow: User 'user123' (create) can create a song within their playlist.
     * @deny: User 'user456' (delete) cannot delete a song from 'user123's playlist.
     * @principle: Inherits ownership from the parent playlist.
     */
    match /users/{userId}/playlists/{playlistId}/songs/{songId} {

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description: Allows public read access to the global song catalog.  Only the song's creator can update and delete, but only if the song doesn't exist.
     * @path: /songs/{songId}
     * @allow: Any user (get) can read a song's metadata.
     * @allow: User 'user123' (create) can create a song with creatorId 'user123'.
     * @deny: User 'user456' (update) cannot update a song created by 'user123'.
     * @principle: Public read access with owner-only writes.
     */
    match /songs/{songId} {
       function isOwner(ownerId) {
        return request.auth.uid == ownerId;
      }

      function isSignedIn() {
        return request.auth != null;
      }
      
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.creatorId == request.auth.uid;
      allow update: if isSignedIn() && isOwner(resource.data.creatorId);
      allow delete: if isSignedIn() && isOwner(resource.data.creatorId);
    }

    /**
     * @description: Allows anyone to read chat messages for songs.
     * @path: /songs/{songId}/messages/{messageId}
     * @allow: Any user (get) can read a message.
     * @deny: User 'user123' (delete) cannot delete a message (no write access granted).
     * @principle: Public read access to chat messages.
     */
    match /songs/{songId}/messages/{messageId} {

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }
  }
}