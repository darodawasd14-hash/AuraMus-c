/**
 * @fileoverview Firestore Security Rules for the Aura application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user profiles, playlists, and follows. Users can only read and write their own data.
 * Public read access is granted to the global songs collection, with ownership-based restrictions on create, update, and delete operations.
 * Private chats are secured using a shared access model, where only participants can read and write messages.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles.
 * - /users/{userId}/playlists/{playlistId}: Stores user playlists.
 * - /users/{userId}/playlists/{playlistId}/songs/{songId}: Stores songs within a playlist.
 * - /songs/{songId}: Stores a global catalog of songs, publicly readable.
 * - /songs/{songId}/messages/{messageId}: Stores chat messages for a specific song.
 * - /users/{userId}/followers/{followerId}: Stores followers of a user.
 * - /users/{userId}/following/{followingId}: Stores users a user is following.
 * - /chats/{chatId}: Stores private chat rooms.
 * - /chats/{chatId}/messages/{messageId}: Stores messages within a chat room.
 *
 * Key Security Decisions:
 * - Users can only manage their own profiles and playlists.
 * - The global songs collection is publicly readable but requires ownership for modification.
 * - Chat messages are restricted to participants of the chat.
 * - Data shapes are not strictly validated, focusing on authorization.
 *
 * Denormalization for Authorization:
 * - The rules rely on the `userId` field in playlists to match the parent `userId` path segment.
 * - Chat documents contain a `participantIds` array for easy access control.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile documents. Users can only manage their own profile.
     * @path /users/{userId}
     * @allow (create, update, delete) - User 'test_user' with UID 'test_user' can create their profile.
     * @allow (get, list) - User 'test_user' with UID 'test_user' can read their profile.
     * @deny (create, update, delete) - User 'other_user' with UID 'other_user' cannot modify user 'test_user' profile.
     * @principle Enforces document ownership for writes and reads for user profiles.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if true;
      allow list: if false; // User listing is disabled

      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to user playlists. Users can only manage their own playlists.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (create, update, delete) - User 'test_user' with UID 'test_user' can create a playlist under their profile.
     * @allow (get, list) - User 'test_user' with UID 'test_user' can read their playlists.
     * @deny (create, update, delete) - User 'other_user' with UID 'other_user' cannot modify user 'test_user' playlists.
     * @principle Enforces document ownership for writes and reads for playlists.
     */
    match /users/{userId}/playlists/{playlistId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

       function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to songs within a user's playlist. Users can only manage songs in their own playlists.
     * @path /users/{userId}/playlists/{playlistId}/songs/{songId}
     * @allow (create, update, delete) - User 'test_user' with UID 'test_user' can add songs to their playlist.
     * @allow (get, list) - User 'test_user' with UID 'test_user' can read songs in their playlist.
     * @deny (create, update, delete) - User 'other_user' with UID 'other_user' cannot modify user 'test_user' playlists' songs.
     * @principle Enforces document ownership for writes and reads for playlist songs.
     */
    match /users/{userId}/playlists/{playlistId}/songs/{songId} {
        function isOwner(userId) {
            return request.auth != null && request.auth.uid == userId;
        }

        function isExistingOwner(userId) {
          return isOwner(userId) && resource != null;
        }

        allow get: if isOwner(userId);
        allow list: if isOwner(userId);

        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to the global song catalog.  Read access is public, but modifications require ownership.
     * @path /songs/{songId}
     * @allow (get, list) - Any user, even unauthenticated, can read the song.
     * @allow (create, update, delete) - Only the song creator can modify the song.  The song document must contain an `ownerId` field.
     * @deny (create, update, delete) - A non-owner cannot modify the song.
     * @principle Public read access with owner-only writes.
     */
    match /songs/{songId} {
      allow get, list: if true;

      // CRITICAL: Cannot implement owner-only writes. The 'Song' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Controls access to chat messages for a specific song.
     * @path /songs/{songId}/messages/{messageId}
     */
    match /songs/{songId}/messages/{messageId} {
        allow get, list, create, update, delete: if true;
    }

     /**
      * @description Controls access to user followers. Users can only manage their own followers.
      * @path /users/{userId}/followers/{followerId}
      * @allow (create, delete) - User 'test_user' with UID 'test_user' can manage their followers.
      * @allow (get, list) - User 'test_user' with UID 'test_user' can read their followers.
      * @deny (create, delete) - User 'other_user' with UID 'other_user' cannot modify user 'test_user' followers.
      * @principle Enforces document ownership for writes and reads for followers.
      */
    match /users/{userId}/followers/{followerId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to users a user is following. Users can only manage their own following list.
     * @path /users/{userId}/following/{followingId}
     * @allow (create, delete) - User 'test_user' with UID 'test_user' can manage who they are following.
     * @allow (get, list) - User 'test_user' with UID 'test_user' can read who they are following.
     * @deny (create, delete) - User 'other_user' with UID 'other_user' cannot modify user 'test_user' following list.
     * @principle Enforces document ownership for writes and reads for the following list.
     */
    match /users/{userId}/following/{followingId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to private chat rooms. Only participants can access the chat.
     * @path /chats/{chatId}
     * @allow (get, list) - User 'test_user' with UID 'test_user' can read the chat if they are a participant.
     * @allow (create, update, delete) - User 'test_user' with UID 'test_user' can manage the chat if they are a participant.
     * @deny (get, list) - User 'other_user' with UID 'other_user' cannot read the chat if they are not a participant.
     * @principle Enforces shared access for chat rooms.
     */
    match /chats/{chatId} {
      function isParticipant() {
        return request.auth != null && request.resource.data.participantIds.hasAny([request.auth.uid]);
      }

       function isExistingParticipant() {
        return request.auth != null && resource.data.participantIds.hasAny([request.auth.uid]);
      }


      allow get: if isExistingParticipant();
      allow list: if false; // Listing chats is generally not a good idea, could leak information.

      allow create: if isParticipant();
      allow update: if isExistingParticipant();
      allow delete: if false; // Deleting a chat is generally not allowed.
    }

    /**
     * @description Controls access to messages within a private chat room. Only participants can access the messages.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get, list, create) - User 'test_user' with UID 'test_user' can read and create messages in the chat if they are a participant.
     * @deny (get, list, create) - User 'other_user' with UID 'other_user' cannot read or create messages in the chat if they are not a participant.
     * @principle Enforces shared access for chat messages.
     */
    match /chats/{chatId}/messages/{messageId} {
        function isChatParticipant(chatId) {
          return get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]);
        }
        allow get: if isChatParticipant(chatId);
        allow list: if isChatParticipant(chatId);
        allow create: if isChatParticipant(chatId);
        allow update, delete: if false;
    }
  }
}