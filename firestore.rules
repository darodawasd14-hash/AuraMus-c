/**
 * @fileoverview Firestore Security Rules for Aura application.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for user profiles, playlists, and songs within those playlists.
 * Public read access is granted to the 'songs' collection.
 * Private chat messages are restricted to authenticated participants of the chat.
 *
 * Data Structure:
 * - /users/{userId}: User profile data.
 * - /users/{userId}/playlists/{playlistId}: Playlists owned by a specific user.
 * - /users/{userId}/playlists/{playlistId}/songs/{songId}: Songs within a user's playlist.
 * - /songs/{songId}: Publicly accessible song catalog.
 * - /songs/{songId}/messages/{messageId}: Chat messages related to a song (publicly accessible).
 * - /users/{userId}/followers/{followerId}: Users following a given user.
 * - /users/{userId}/following/{followingId}: Users a given user is following.
 * - /chats/{chatId}: Private chats between users.
 * - /chats/{chatId}/messages/{messageId}: Messages within a private chat.
 *
 * Key Security Decisions:
 * - Users can only read and write their own profile data and playlists.
 * - The song catalog is publicly readable but only modifiable through server-side logic.
 * - Chat messages for songs are publicly accessible.
 * - Follower/Following lists are publicly readable, but only the user can modify their own lists.
 * - Private chat messages are only accessible to authenticated participants of the chat.
 *
 * Denormalization for Authorization:
 * - The `Playlist` entity requires a `userId` field to match the path `/users/{userId}/playlists/{playlistId}`.
 * - The `Song` entity in `/users/{userId}/playlists/{playlistId}/songs/{songId}` does not require a `userId` field, as ownership is implied by the path.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows users to read and write their own profile data.
     * @path /users/{userId}
     * @allow (create) - Authenticated user creates their own profile.
     * @allow (get, list, update, delete) - Authenticated user reads/modifies their own profile.
     * @deny (create) - Unauthenticated user attempts to create a profile.
     * @deny (update, delete) - Authenticated user attempts to modify another user's profile.
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get, list: if true;
      allow create: if isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update, delete: if isOwner(userId) && resource.data.id == userId;
    }

    /**
     * @description Allows users to manage their own playlists.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (create) - Authenticated user creates a playlist under their profile.
     * @allow (get, list, update, delete) - Authenticated user reads/modifies their own playlist.
     * @deny (create) - Unauthenticated user attempts to create a playlist.
     * @deny (update, delete) - Authenticated user attempts to modify another user's playlist.
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/playlists/{playlistId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update, delete: if isOwner(userId) && resource.data.userId == userId;
    }

    /**
     * @description Allows users to manage songs within their playlists.
     * @path /users/{userId}/playlists/{playlistId}/songs/{songId}
     * @allow (create) - Authenticated user adds a song to their playlist.
     * @allow (get, list, update, delete) - Authenticated user reads/modifies songs in their own playlist.
     * @deny (create) - Unauthenticated user attempts to add a song.
     * @deny (update, delete) - Authenticated user attempts to modify songs in another user's playlist.
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/playlists/{playlistId}/songs/{songId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update, delete: if isOwner(userId);
    }

    /**
     * @description Allows public read access to the song catalog. Only trusted servers can modify it.
     * @path /songs/{songId}
     * @allow (get, list) - Any user can read the song catalog.
     * @deny (create, update, delete) - No client-side writes allowed.
     * @principle Public read, owner-only writes (enforced through server-side logic).
     */
    match /songs/{songId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add server-side validation
    }

    /**
     * @description Allows any user to read messages for a specific song. Only trusted servers can modify it.
     * @path /songs/{songId}/messages/{messageId}
     * @allow (get, list) - Any user can read the messages for a song.
     * @deny (create, update, delete) - No client-side writes allowed.
     * @principle Public read, owner-only writes (enforced through server-side logic).
     */
    match /songs/{songId}/messages/{messageId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add server-side validation
    }

    /**
     * @description Allows a user to manage their own followers.
     * @path /users/{userId}/followers/{followerId}
     * @allow (get, list) - Anyone can view a user's followers.
     * @allow (create, delete) - Only the user can add/remove followers (meaning THEY are following someone).
     * @deny (update) - Followers are managed through create/delete.
     * @principle Public read of followers, owner-only writes for adding/removing.
     */
    match /users/{userId}/followers/{followerId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get, list: if true;
      allow create, delete: if isOwner(userId);
      allow update: if false;
    }

    /**
     * @description Allows a user to manage who they are following.
     * @path /users/{userId}/following/{followingId}
     * @allow (get, list) - Anyone can view who a user is following.
     * @allow (create, delete) - Only the user can add/remove who they are following.
     * @deny (update) - Following relationships are managed through create/delete.
     * @principle Public read of following, owner-only writes for adding/removing.
     */
    match /users/{userId}/following/{followingId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get, list: if true;
      allow create, delete: if isOwner(userId);
      allow update: if false;
    }

    /**
     * @description Manages access to private chats between users.  Participants can read/write messages.
     * @path /chats/{chatId}
     * @allow (read, write) - Only authenticated participants can read and write the chat and messages.
     * @deny - Non-participants are denied access.
     * @principle Shared access (closed collaborators).
     */
    match /chats/{chatId} {
        /**
         * @description Allows participants to read and write chat messages within a specific chat.
         * @path /chats/{chatId}/messages/{messageId}
         * @allow (read, write) - Authenticated participant can read/write messages in the chat.
         * @deny - Non-participants are denied access.
         * @principle Shared access (closed collaborators).
         */
        match /messages/{messageId} {
          function isSignedIn() {
            return request.auth != null;
          }

          function isParticipant(chatId) {
            return isSignedIn() && request.auth.uid in chatId.split('_');
          }
          allow read, write: if isParticipant(chatId);
        }
    }
  }
}