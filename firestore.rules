rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile data. Only the user themselves can read or write their profile.
     * @path /users/{userId}
     * @allow (create, update, delete) if request.auth.uid == userId
     * @allow (get, list) if request.auth.uid == userId
     * @deny (create, update, delete) if request.auth.uid != userId
     * @deny (get, list) if request.auth.uid != userId
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isOwner(userId);
      allow list: if false; // Disallowing user listing for privacy.
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);

      /**
       * @description Controls access to user-specific playlists. Only the owner can read and write playlists.
       * @path /users/{userId}/playlists/{playlistId}
       * @allow (create, update, delete) if request.auth.uid == userId
       * @allow (get, list) if request.auth.uid == userId
       * @deny (create, update, delete) if request.auth.uid != userId
       * @deny (get, list) if request.auth.uid != userId
       * @principle Enforces document ownership for all playlist operations.
       */
      match /playlists/{playlistId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isOwner(userId);
        allow delete: if isOwner(userId);

        /**
         * @description Controls access to songs within a user's playlist. Only the owner can read and write songs in their playlists.
         * @path /users/{userId}/playlists/{playlistId}/songs/{songId}
         * @allow (create, update, delete) if request.auth.uid == userId
         * @allow (get, list) if request.auth.uid == userId
         * @deny (create, update, delete) if request.auth.uid != userId
         * @deny (get, list) if request.auth.uid != userId
         * @principle Enforces document ownership for all song operations within playlists.
         */
        match /songs/{songId} {
          allow get: if isOwner(userId);
          allow list: if isOwner(userId);
          allow create: if isOwner(userId);
          allow update: if isOwner(userId);
          allow delete: if isOwner(userId);
        }
      }

       /**
         * @description Controls access to followers for a user. Only the user can manage their followers list.
         * @path /users/{userId}/followers/{followerId}
         * @allow (create, delete) if request.auth.uid == userId
         * @allow (get, list) if isOwner(userId);
         * @deny (create, delete) if request.auth.uid != userId
         * @deny (get, list) if !isOwner(userId);
         * @principle Enforces document ownership for managing followers.
         */
      match /followers/{followerId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if false;
        allow delete: if isOwner(userId);
      }

      /**
       * @description Controls access to the list of users a user is following. Only the user can manage their following list.
       * @path /users/{userId}/following/{followingId}
       * @allow (create, delete) if request.auth.uid == userId
       * @allow (get, list) if isOwner(userId);
       * @deny (create, delete) if request.auth.uid != userId
       * @deny (get, list) if !isOwner(userId);
       * @principle Enforces document ownership for managing the following list.
       */
      match /following/{followingId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if false;
        allow delete: if isOwner(userId);
      }
    }

    /**
     * @description Controls access to the global song catalog. Read access is public, but writes are restricted to valid owners (e.g., the user who uploaded the song).
     * @path /songs/{songId}
     * @allow get, list: if true
     * @allow create, update, delete: if false // TODO: Add owner validation once the schema is updated with an ownership field.
     * @deny create, update, delete: if true
     * @principle Allows public reads but restricts writes to owners (once implemented).
     */
    match /songs/{songId} {
        allow get, list: if true;
        allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.

        /**
         * @description Controls access to chat messages for a specific song.
         * @path /songs/{songId}/messages/{messageId}
         * @allow create, update, delete: if isSignedIn()
         * @allow get, list: if true;
         * @deny create, update, delete: if false
         * @principle Messages related to a song are viewable to anyone but only the authenticated user is allowed to create/update/delete them.
         */
        match /messages/{messageId} {
          allow get, list: if true;
          allow create: if isSignedIn();
          allow update: if isSignedIn();
          allow delete: if isSignedIn();
        }
    }

    /**
     * @description Controls access to private chats between users. Only participants can read and write chat data.
     * @path /chats/{chatId}
     * @allow (get, list) if request.auth.uid in resource.data.participantIds
     * @allow (create, update, delete) if request.auth.uid in resource.data.participantIds
     * @deny (get, list) if !(request.auth.uid in resource.data.participantIds)
     * @deny (create, update, delete) if !(request.auth.uid in resource.data.participantIds)
     * @principle Implements a closed-collaborator access pattern for private chats.
     */
    match /chats/{chatId} {
      function isParticipant() {
        return request.auth.uid in resource.data.participantIds;
      }

      allow get, list: if isParticipant();
      allow create: if request.resource.data.keys().hasOnly(['participantIds']) && request.resource.data.participantIds.size() > 0 && request.auth.uid in request.resource.data.participantIds;
      allow update: if isParticipant();
      allow delete: if false; // Deleting chats is not allowed

      /**
       * @description Controls access to messages within a private chat. Only chat participants can read and write messages.
       * @path /chats/{chatId}/messages/{messageId}
       * @allow (get, list) if request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds
       * @allow (create, update, delete) if request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds
       * @deny (get, list) if !(request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds)
       * @deny (create, update, delete) if !(request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds)
       * @principle Inherits the closed-collaborator access pattern from the parent chat document.
       */
      match /messages/{messageId} {
        function isChatParticipant() {
          return request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds;
        }
        allow get, list: if isChatParticipant();
        allow create: if isChatParticipant();
        allow update: if isChatParticipant();
        allow delete: if isChatParticipant();
      }
    }
  }
}