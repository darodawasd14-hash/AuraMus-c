/**
 * @fileoverview Firestore Security Rules for the Aura application.
 *
 * Core Philosophy:
 * This ruleset prioritizes user data ownership and secure access to shared resources.
 * It enforces a strict access control model, ensuring that users can only read, write,
 * update, or delete data that they own, or that they have been explicitly granted
 * permission to access.
 *
 * Data Structure:
 * The Firestore database is organized around users. Each user has a profile document
 * under `/users/{userId}`, and playlists under `/users/{userId}/playlists/{playlistId}`.
 * Songs can be stored both within user playlists and in a global `/songs/{songId}` collection.
 * Chat messages are stored under `/songs/{songId}/messages/{messageId}` for public
 * song-specific chats and under `/chats/{chatId}/messages/{messageId}` for private chats.
 * Follow relationships are tracked in `/users/{userId}/followers/{followerId}` and
 * `/users/{userId}/following/{followingId}`. Private chats exist under `/chats/{chatId}`.
 *
 * Key Security Decisions:
 * - Users can only manage their own profile and playlist data.
 * - Public song catalog is readable by everyone, but modifications are restricted to authorized users.
 * - Chat messages associated with songs are accessible to everyone. Private chats messages are restricted to members of the chat.
 * - Listing of followers and followings is allowed for the respective user.
 * - Data validation is minimal to allow for rapid prototyping, focusing primarily on
 *   ensuring data consistency between document IDs and ownership fields.
 *
 * Denormalization for Authorization:
 * - The `Playlist` entity has a `userId` field to simplify ownership checks, avoiding the
 *   need for complex queries to determine playlist ownership.
 * - The `Message` entity under `/songs/{songId}/messages/{messageId}` does not require an `ownerId` field,
 *   as all messages in a song's message board are publicly accessible. The `sender.uid` field
 *   is sufficient for identifying the message's author.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages user profile data.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' creates their profile.
     *          request.auth.uid == 'user123' and request.resource.data.id == 'user123'
     * @allow (get) Any user can retrieve profile information.
     * @allow (update) User with ID 'user123' updates their profile.
     *          request.auth.uid == 'user123' and resource.data.id == 'user123'
     * @allow (delete) User with ID 'user123' deletes their profile.
     *          request.auth.uid == 'user123' and resource.data.id == 'user123'
     * @deny  (create) User with ID 'user456' attempts to create profile for 'user123'.
     *          request.auth.uid == 'user456' and request.resource.data.id == 'user123'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow get: if true;
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages user playlists.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (create) User with ID 'user123' creates a playlist.
     *          request.auth.uid == 'user123' and request.resource.data.userId == 'user123'
     * @allow (get) User with ID 'user123' retrieves their playlist.
     *          request.auth.uid == 'user123' and resource.data.userId == 'user123'
     * @allow (list) User with ID 'user123' lists their playlists.
     *          request.auth.uid == 'user123'
     * @allow (update) User with ID 'user123' updates their playlist.
     *          request.auth.uid == 'user123' and resource.data.userId == 'user123'
     * @allow (delete) User with ID 'user123' deletes their playlist.
     *          request.auth.uid == 'user123' and resource.data.userId == 'user123'
     * @deny (create) User with ID 'user456' attempts to create a playlist for 'user123'.
     *          request.auth.uid == 'user456' and request.resource.data.userId == 'user123'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/playlists/{playlistId} {
      allow get: if isSignedIn() && isOwner(userId) && resource.data.userId == userId;
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && resource.data.userId == userId;
      allow delete: if isSignedIn() && isExistingOwner(userId) && resource.data.userId == userId;
    }

    /**
     * @description Manages songs within a playlist.
     * @path /users/{userId}/playlists/{playlistId}/songs/{songId}
     * @allow (create) User with ID 'user123' adds a song to their playlist.
     *          request.auth.uid == 'user123'
     * @allow (get) User with ID 'user123' retrieves a song from their playlist.
     *          request.auth.uid == 'user123'
     * @allow (list) User with ID 'user123' lists songs in their playlist.
     *          request.auth.uid == 'user123'
     * @allow (update) User with ID 'user123' updates a song in their playlist.
     *          request.auth.uid == 'user123'
     * @allow (delete) User with ID 'user123' deletes a song from their playlist.
     *          request.auth.uid == 'user123'
     * @deny (create) User with ID 'user456' attempts to add a song to 'user123' playlist.
     *          request.auth.uid == 'user456'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/playlists/{playlistId}/songs/{songId} {
      allow get: if isSignedIn() && isPlaylistOwner(userId, playlistId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isPlaylistOwner(userId, playlistId);
      allow update: if isSignedIn() && isExistingPlaylistOwner(userId, playlistId);
      allow delete: if isSignedIn() && isExistingPlaylistOwner(userId, playlistId);
    }

    /**
     * @description Manages the global song catalog.
     * @path /songs/{songId}
     * @allow (get) Any user can retrieve song information.
     * @allow (list) Any user can list songs.
     * @allow (create) Any signed-in user can create a song.
     * @allow (update) Only the owner of the song can update it.
     * @allow (delete) Only the owner of the song can delete it.
     * @principle Public read, owner-only writes.
     */
    match /songs/{songId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Manages chat messages for a specific song.
     * @path /songs/{songId}/messages/{messageId}
     * @allow (get) Any user can retrieve messages for a song.
     * @allow (list) Any user can list messages for a song.
     * @allow (create) Any signed-in user can create a message.
     * @allow (update) No one can update a message.
     * @allow (delete) No one can delete a message.
     * @principle Public read, authenticated writes.
     */
    match /songs/{songId}/messages/{messageId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages the followers of a user.
     * @path /users/{userId}/followers/{followerId}
     * @allow (get) Any user can get followers.
     * @allow (list) The user can list their followers.
     * @allow (create) Any signed-in user can create a follower entry.
     * @allow (update) No one can update a follower entry.
     * @allow (delete) Any signed-in user can delete a follower entry.
     * @principle Authenticated access.
     */
     match /users/{userId}/followers/{followerId} {
        allow get: if isSignedIn();
        allow list: if isSignedIn() && isOwner(userId);
        allow create: if isSignedIn();
        allow update: if false;
        allow delete: if isSignedIn();
     }

    /**
     * @description Manages the users that a user is following.
     * @path /users/{userId}/following/{followingId}
     * @allow (get) Any user can get the followings.
     * @allow (list) The user can list their followings.
     * @allow (create) Any signed-in user can create a following entry.
     * @allow (update) No one can update a following entry.
     * @allow (delete) Any signed-in user can delete a following entry.
     * @principle Authenticated access.
     */
     match /users/{userId}/following/{followingId} {
        allow get: if isSignedIn();
        allow list: if isSignedIn() && isOwner(userId);
        allow create: if isSignedIn();
        allow update: if false;
        allow delete: if isSignedIn();
     }

    /**
     * @description Manages private chats between users.
     * @path /chats/{chatId}
     * @allow (get) Only participants can retrieve a chat.
     * @allow (list) No one can list chats.
     * @allow (create) Any signed-in user can create a chat. The user must be included in the participantIds.
     * @allow (update) Only participants can update a chat.
     * @allow (delete) No one can delete a chat.
     * @principle Shared access, closed collaborators.
     */
    match /chats/{chatId} {
      allow get: if isSignedIn() && isChatParticipant();
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.participantIds.hasAny([request.auth.uid]);
      allow update: if isSignedIn() && isChatParticipant();
      allow delete: if false;
    }

    /**
     * @description Manages messages within a private chat.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get) Only participants can retrieve messages from a chat.
     * @allow (list) Only participants can list messages from a chat.
     * @allow (create) Only participants can create messages in a chat.
     * @allow (update) No one can update a message.
     * @allow (delete) No one can delete a message.
     * @principle Shared access, closed collaborators.
     */
    match /chats/{chatId}/messages/{messageId} {
      allow get: if isSignedIn() && isChatParticipant();
      allow list: if isSignedIn() && isChatParticipant();
      allow create: if isSignedIn() && isChatParticipant();
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Checks if the current user is signed in.
     * @returns {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user ID matches the authenticated user's ID.
     * @param {string} userId The user ID to check.
     * @returns {boolean} True if the user IDs match, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the user ID matches the authenticated user's ID and the resource exists
     * @param {string} userId The user ID to check.
     * @returns {boolean} True if the user IDs match, false otherwise.
     */
    function isExistingOwner(userId) {
      return request.auth.uid == userId && resource != null;
    }

    /**
     * @description Checks if the user is the owner of the playlist.
     * @param {string} userId The user ID to check.
     * @param {string} playlistId The playlist ID to check.
     * @returns {boolean} True if the user owns the playlist, false otherwise.
     */
    function isPlaylistOwner(userId, playlistId) {
        return get(/databases/$(database)/documents/users/$(userId)/playlists/$(playlistId)).data.userId == request.auth.uid;
    }

     /**
     * @description Checks if the user is the owner of the playlist and the resource exists.
     * @param {string} userId The user ID to check.
     * @param {string} playlistId The playlist ID to check.
     * @returns {boolean} True if the user owns the playlist and the resource exists, false otherwise.
     */
    function isExistingPlaylistOwner(userId, playlistId) {
        return get(/databases/$(database)/documents/users/$(userId)/playlists/$(playlistId)).data.userId == request.auth.uid && resource != null;
    }

    /**
     * @description Checks if the current user is a participant in the chat.
     * @returns {boolean} True if the user is a participant, false otherwise.
     */
    function isChatParticipant() {
      return resource.data.participantIds.hasAny([request.auth.uid]);
    }
  }
}