/**
 * @fileoverview Firestore Security Rules for the Aura application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user profiles and playlists.
 * Users can only read and write their own data. Public read access is granted to the `/songs` collection.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile data.
 * - /users/{userId}/playlists/{playlistId}: Stores playlist metadata for each user.
 * - /users/{userId}/playlists/{playlistId}/songs/{songId}: Stores songs for a specific playlist.
 * - /songs/{songId}: Stores all songs added by any user, forming a global catalog.
 * - /songs/{songId}/messages/{messageId}: Stores chat messages for a specific song.
 * - /users/{userId}/followers/{followerId}: Stores the followers of a user.
 * - /users/{userId}/following/{followingId}: Stores the users a user is following.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Default security posture for ambiguous relationships is strict owner-only access.
 * - The `songs` collection is publicly readable, but writes are restricted.
 *
 * Denormalization for Authorization:
 * - The `Playlist` entity requires `userId` to be stored to enforce ownership.
 * - The `Message` entity requires `sender.uid` to be stored to identify the message sender.
 *
 * Structural Segregation:
 * - Playlists are stored as subcollections under `/users/{userId}` to ensure private user data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure access to user profiles.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their profile.
     *   Request: { "auth": { "uid": "user123" }, "resource.data.id": "user123" }
     * @allow (get) User with ID 'user123' can read their profile.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (update) User with ID 'user123' can update their profile.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (delete) User with ID 'user123' can delete their profile.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (create) User with ID 'user456' cannot create a profile for 'user123'.
     *   Request: { "auth": { "uid": "user456" }, "resource.data.id": "user123" }
     * @deny (get) User with ID 'user456' cannot read the profile of 'user123'.
     *   Request: { "auth": { "uid": "user456" } }
     * @principle Enforces document ownership for writes and reads.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && exists(/databases/$(database)/documents/users/$(userId));
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure access to user playlists.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (create) User with ID 'user123' can create a playlist in their profile.
     *   Request: { "auth": { "uid": "user123" }, "resource.data.userId": "user123" }
     * @allow (get) User with ID 'user123' can read a playlist in their profile.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (list) User with ID 'user123' can list playlists in their profile.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (update) User with ID 'user123' can update a playlist in their profile.
     *   Request: { "auth": { "uid": "user123" }, "resource.data.userId": "user123" }
     * @allow (delete) User with ID 'user123' can delete a playlist in their profile.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (create) User with ID 'user456' cannot create a playlist for 'user123'.
     *   Request: { "auth": { "uid": "user456" }, "resource.data.userId": "user123" }
     * @deny (get) User with ID 'user456' cannot read playlists of 'user123'.
     *   Request: { "auth": { "uid": "user456" } }
     * @principle Restricts access to a user's own playlist data.
     */
    match /users/{userId}/playlists/{playlistId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return request.auth != null && request.auth.uid == userId && exists(/databases/$(database)/documents/users/$(userId)/playlists/$(playlistId));
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure access to songs within a user's playlist.
     * @path /users/{userId}/playlists/{playlistId}/songs/{songId}
     * @allow (create) User with ID 'user123' can add a song to their playlist.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (get) User with ID 'user123' can read a song in their playlist.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (list) User with ID 'user123' can list songs in their playlist.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (update) User with ID 'user123' can update a song in their playlist.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (delete) User with ID 'user123' can delete a song from their playlist.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (create) User with ID 'user456' cannot add a song to 'user123' playlist.
     *   Request: { "auth": { "uid": "user456" } }
     * @deny (get) User with ID 'user456' cannot read songs of 'user123'.
     *   Request: { "auth": { "uid": "user456" } }
     * @principle Restricts access to a user's own playlist songs.
     */
    match /users/{userId}/playlists/{playlistId}/songs/{songId} {
      function isPlaylistOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingPlaylistOwner(userId, playlistId, songId) {
        return request.auth != null && request.auth.uid == userId && exists(/databases/$(database)/documents/users/$(userId)/playlists/$(playlistId)/songs/$(songId));
      }

      allow get: if isPlaylistOwner(userId);
      allow list: if isPlaylistOwner(userId);
      allow create: if isPlaylistOwner(userId);
      allow update: if isExistingPlaylistOwner(userId, playlistId, songId);
      allow delete: if isExistingPlaylistOwner(userId, playlistId, songId);
    }

    /**
     * @description Allows public read access to the global song catalog, but restricts writes.
     * @path /songs/{songId}
     * @allow (get) Any user can read song details.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (list) Any user can list songs.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (create) No one can create a song without specific authorization logic.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (update) No one can update a song without specific authorization logic.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (delete) No one can delete a song without specific authorization logic.
     *   Request: { "auth": { "uid": "user123" } }
     * @principle Provides public read access while restricting write access to authorized users.
     */
    match /songs/{songId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Secure access to chat messages for a specific song.
     * @path /songs/{songId}/messages/{messageId}
     * @allow (create) Any signed-in user can create a message for a song.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (get) Any signed-in user can read a message for a song.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (list) Any signed-in user can list messages for a song.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (update) Only the message sender can update their message.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (delete) Only the message sender can delete their message.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (create) Anonymous user cannot create a message for a song.
     *   Request: { "auth": { "uid": null } }
     * @deny (update) User with ID 'user456' cannot update message of 'user123'.
     *   Request: { "auth": { "uid": "user456" } }
     * @principle Messages should be secure, only the owner can edit/delete.
     */
    match /songs/{songId}/messages/{messageId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isMessageSender(messageSenderId) {
        return isSignedIn() && request.auth.uid == messageSenderId;
      }

      function isExistingMessageSender(songId, messageId) {
        return isSignedIn() && exists(/databases/$(database)/documents/songs/$(songId)/messages/$(messageId));
      }

      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isExistingMessageSender(songId, messageId) && request.auth.uid == resource.data.sender.uid;
      allow delete: if isExistingMessageSender(songId, messageId) && request.auth.uid == resource.data.sender.uid;
    }

    /**
     * @description Secure access to user followers.
     * @path /users/{userId}/followers/{followerId}
     * @allow (create) Any signed-in user can follow another user.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (get) Only the followed user can see their followers.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (list) Only the followed user can list their followers.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (delete) Only the follower can unfollow.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (create) Anonymous user cannot follow another user.
     *   Request: { "auth": { "uid": null } }
     * @deny (get) User 'user456' cannot see the followers of 'user123'.
     *   Request: { "auth": { "uid": "user456" } }
     * @principle Follower list are restricted to the user being followed.
     */
    match /users/{userId}/followers/{followerId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if request.auth.uid == followerId;
    }

    /**
     * @description Secure access to users a user is following.
     * @path /users/{userId}/following/{followingId}
     * @allow (create) Any signed-in user can follow another user.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (get) Only the user can see who they are following.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (list) Only the user can list who they are following.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (delete) Only the user can unfollow.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (create) Anonymous user cannot follow another user.
     *   Request: { "auth": { "uid": null } }
     * @deny (get) User 'user456' cannot see who 'user123' is following.
     *   Request: { "auth": { "uid": "user456" } }
     * @principle Following list are restricted to the user who is following.
     */
    match /users/{userId}/following/{followingId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if request.auth.uid == userId;
    }
  }
}