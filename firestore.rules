/**
 * @fileOverview Firestore Security Rules for Aura application.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for user data and playlists. Users can only read, create, update, and delete their own data. Public read access is granted to the 'songs' collection, but write access is restricted to owners. Follower/Following collections implement user following functionality.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile information.
 * - /users/{userId}/playlists/{playlistId}: Stores user playlists.
 * - /users/{userId}/playlists/{playlistId}/songs/{songId}: Stores songs within a playlist.
 * - /songs/{songId}: Stores a global catalog of songs.
 * - /songs/{songId}/messages/{messageId}: Stores chat messages for a specific song.
 * - /users/{userId}/followers/{followerId}: Stores followers of a user.
 * - /users/{userId}/following/{followingId}: Stores users a user is following.
 *
 * Key Security Decisions:
 * - Users can only manage their own playlists and songs within those playlists.
 * - The 'songs' collection is publicly readable but writable only by the user who added the song.
 * - Listing of other users' playlists is implicitly denied (no `list` rule on `/users/{userId}/playlists`).
 * - Follower/Following collections are secured such that only the owner of the profile can manage their followers/following.
 *
 * Denormalization for Authorization:
 * - The `Playlist` entity has a `userId` field to easily enforce ownership.
 * - The `Song` entity, when stored in the global `songs` collection, needs an `ownerId` field for write access control.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile documents.
     * @path /databases/{database}/documents/users/{userId}
     * @allow (create) - User with UID 'user123' can create their own profile document.
     * @allow (get, update, delete) - User with UID 'user123' can read, update, and delete their own profile document.
     * @deny (create) - User with UID 'anotherUser' cannot create a profile document for 'user123'.
     * @deny (update, delete) - User with UID 'anotherUser' cannot update or delete the profile document for 'user123'.
     * @principle Enforces document ownership.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isSignedIn() && isOwner(userId) && resource.data.id == resource.data.id;
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to user playlists.
     * @path /databases/{database}/documents/users/{userId}/playlists/{playlistId}
     * @allow (create, get, update, delete) - User with UID 'user123' can manage their own playlists.
     * @deny (create, get, update, delete) - User with UID 'anotherUser' cannot manage playlists for 'user123'.
     * @principle Enforces document ownership for playlists.
     */
    match /users/{userId}/playlists/{playlistId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isOwner(userId) && resource.data.userId == resource.data.userId;
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to songs within a user's playlist.
     * @path /databases/{database}/documents/users/{userId}/playlists/{playlistId}/songs/{songId}
     * @allow (create, get, update, delete) - User with UID 'user123' can manage songs in their own playlists.
     * @deny (create, get, update, delete) - User with UID 'anotherUser' cannot manage songs in playlists for 'user123'.
     * @principle Enforces document ownership for playlist songs.
     */
    match /users/{userId}/playlists/{playlistId}/songs/{songId} {
       function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to the global song catalog.  Read access is public, but write access is restricted to the owner of the song.
     * @path /databases/{database}/documents/songs/{songId}
     * @allow (get, list) - Any user can read the song details.
     * @allow (create) - User with UID 'user123' can create a new song with ownerId set to 'user123'.
     * @allow (update, delete) - User with UID 'user123' can update/delete a song where resource.data.ownerId == 'user123'.
     * @deny (create) - User with UID 'anotherUser' cannot create a song and set ownerId to 'user123'.
     * @deny (update, delete) - User with UID 'anotherUser' cannot update/delete a song where resource.data.ownerId == 'user123'.
     * @principle Public read access with owner-only writes.
     */
    match /songs/{songId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(ownerId) {
          return request.auth.uid == ownerId;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && isOwner(resource.data.ownerId);
      allow delete: if isSignedIn() && isOwner(resource.data.ownerId);
    }

    /**
     * @description Controls access to chat messages for a specific song.
     * @path /databases/{database}/documents/songs/{songId}/messages/{messageId}
     * @allow (create, get, list) - Any signed-in user can create and read messages for a song.
     * @deny (update, delete) - No one can update or delete a message (messages are immutable).
     * @principle Public read and create access for messages; no updates or deletes.
     */
    match /songs/{songId}/messages/{messageId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to the list of followers for a user.
     * @path /databases/{database}/documents/users/{userId}/followers/{followerId}
     * @allow (create, get, delete) - The user can manage their own followers.
     * @deny (create, get, delete) - Another user cannot manage the followers of a given user.
     * @principle Enforces document ownership for managing followers.
     */
    match /users/{userId}/followers/{followerId} {
        function isOwner(userId) {
          return request.auth.uid == userId;
        }

        function isSignedIn() {
          return request.auth != null;
        }

        allow get: if isSignedIn() && isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isSignedIn() && isOwner(userId);
        allow update: if false;
        allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to the list of users a user is following.
     * @path /databases/{database}/documents/users/{userId}/following/{followingId}
     * @allow (create, get, delete) - The user can manage who they are following.
     * @deny (create, get, delete) - Another user cannot manage who a given user is following.
     * @principle Enforces document ownership for managing following list.
     */
    match /users/{userId}/following/{followingId} {
        function isOwner(userId) {
          return request.auth.uid == userId;
        }

        function isSignedIn() {
          return request.auth != null;
        }

        allow get: if isSignedIn() && isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isSignedIn() && isOwner(userId);
        allow update: if false;
        allow delete: if isSignedIn() && isOwner(userId);
    }
  }
}