/**
 * @fileoverview Firestore Security Rules for the Aura application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user profiles and playlists. Users can only
 * read and write their own data. Public read access is granted to the "songs" collection, but writes are restricted
 * to authenticated users who must also provide their user ID as the author when creating new songs.
 *
 * Data Structure:
 * - /users/{userId}: User profile information, owned by the user.
 * - /users/{userId}/playlists/{playlistId}: Playlists created by the user.
 * - /users/{userId}/playlists/{playlistId}/songs/{songId}: Songs within a specific playlist, owned by the user.
 * - /songs/{songId}: A public catalog of songs. Anyone can read but only authenticated users can create, update or delete, only if they are the owner.
 * - /songs/{songId}/messages/{messageId}: Chat messages for a specific song.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Public read access to the /songs collection allows for discovery.
 * - The default security posture for ambiguous relationships is strict owner-only access.
 *
 * Denormalization for Authorization:
 * - /songs/{songId} documents should contain a denormalized `authorId` field to track ownership.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description: Secure user profiles. Users can only read and write their own profile data.
     * @path: /users/{userId}
     * @allow: User with UID 'user123' (create, update, get, delete) if request.auth.uid == 'user123'
     * @deny: User with UID 'user456' (create, update, get, delete) if request.auth.uid == 'user123'
     * @principle: Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow read, write: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == request.auth.uid; // Validate that the internal user ID matches the authenticated user's ID on create
    }

    /**
     * @description: Secure playlists. Users can only manage playlists under their own user ID.
     * @path: /users/{userId}/playlists
     * @allow: User with UID 'user123' (list) their own playlists, if request.auth.uid == 'user123'.
     * @deny: User with UID 'user456' (list) user 'user123's playlists, if request.auth.uid == 'user123'.
     * @principle: Restricts access to a user's own data tree.
     */
    match /users/{userId}/playlists {
      allow list: if isSignedIn() && isOwner(userId);

      /**
       * @description: Secure individual playlists. Users can only manage playlists under their own user ID.
       * @path: /users/{userId}/playlists/{playlistId}
       * @allow: User with UID 'user123' (create, update, get, delete) a playlist under their own user ID, if request.auth.uid == 'user123'.
       * @deny: User with UID 'user456' (create, update, get, delete) a playlist under user 'user123's ID, if request.auth.uid == 'user123'.
       * @principle: Enforces document ownership for writes.
       */
      match /playlists/{playlistId} {
        allow get, create, update, delete: if isSignedIn() && isOwner(userId) && resource.data.userId == userId;
      }

      /**
       * @description: Secure songs within playlists. Users can only manage songs within playlists under their own user ID.
       * @path: /users/{userId}/playlists/{playlistId}/songs
       * @allow: User with UID 'user123' (list) the songs in their own playlist, if request.auth.uid == 'user123'.
       * @deny: User with UID 'user456' (list) the songs in user 'user123's playlist, if request.auth.uid == 'user123'.
       * @principle: Restricts access to a user's own data tree.
       */
      match /playlists/{playlistId}/songs {
        allow list: if isSignedIn() && isOwner(userId);
        
        /**
         * @description: Secure individual songs within playlists. Users can only manage songs within playlists under their own user ID.
         * @path: /users/{userId}/playlists/{playlistId}/songs/{songId}
         * @allow: User with UID 'user123' (create, update, get, delete) a song in their own playlist, if request.auth.uid == 'user123'.
         * @deny: User with UID 'user456' (create, update, get, delete) a song in user 'user123's playlist, if request.auth.uid == 'user123'.
         * @principle: Enforces document ownership for writes.
         */
        match /songs/{songId} {
          allow get, create, update, delete: if isSignedIn() && isOwner(userId) && resource.data.userId == userId;
        }
      }
    }

    /**
     * @description: Allow public read access to the songs collection, but restrict writes to authenticated users.
     * @path: /songs/{songId}
     * @allow: Any user (get, list) any song.
     * @allow: User with UID 'user123' (create) a song if request.auth.uid == 'user123' and request.resource.data.authorId == 'user123'.
     * @deny: User with UID 'user456' (create) a song if request.auth.uid == 'user123'.
     * @deny: Unauthenticated user (create, update, delete).
     * @principle: Public read access with owner-only writes.
     */
    match /songs/{songId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.id == songId;
      allow update: if isSignedIn() && resource != null && request.resource.data.id == resource.data.id;
      allow delete: if isSignedIn() && resource != null && request.resource.data.id == resource.data.id;
    }

    /**
     * @description: Secure chat messages for songs. Only allow authenticated users to create messages.
     * @path: /songs/{songId}/messages/{messageId}
     * @allow: Authenticated user (create) a message.
     * @deny: Unauthenticated user (create).
     * @principle: Requires authentication for creating chat messages.
     */
    match /songs/{songId}/messages/{messageId} {
      allow get, list, create: if isSignedIn();
      allow update, delete: if false;
    }

  }

  // Helper function to determine if the user is signed in.
  function isSignedIn() {
    return request.auth != null;
  }

  // Helper function to determine if the user is the owner of the resource.
  function isOwner(userId) {
    return request.auth.uid == userId;
  }
}