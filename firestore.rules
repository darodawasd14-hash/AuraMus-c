/**
 * @fileoverview Firestore Security Rules for the Aura application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user profiles and playlists.
 * Users can only read and write their own profile data and playlists. Songs are publicly readable but only
 * modifiable by their owner. Chat data is restricted to participants.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles.
 * - /users/{userId}/playlists/{playlistId}: Stores playlists owned by the user.
 * - /users/{userId}/playlists/{playlistId}/songs/{songId}: Stores songs in a specific playlist
 * - /songs/{songId}: Stores all songs in a global catalog.
 * - /songs/{songId}/messages/{messageId}: Stores chat messages for a specific song.
 * - /users/{userId}/followers/{followerId}: Stores the followers of a user.
 * - /users/{userId}/following/{followingId}: Stores the users a user is following.
 * - /chats/{chatId}: Stores private chat sessions.
 * - /chats/{chatId}/messages/{messageId}: Stores the messages for a specific private chat room.
 *
 * Key Security Decisions:
 * - Users can only read/write their own user document.
 * - Users can only read/write their own playlists.
 * - Public read access to songs, but only owners can modify.
 * - Chat access is restricted to chat participants.
 * - Listing of followers and followings is allowed to the owner.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secures user profile information. Only the user can read and write their own profile.
     * @path /users/{userId}
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if request.auth != null && request.auth.uid == userId;
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Secures user playlists. Only the user can manage their own playlists.
     * @path /users/{userId}/playlists/{playlistId}
     */
    match /users/{userId}/playlists/{playlistId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Secures songs within a playlist. Only the user who owns the playlist can manage songs.
     * @path /users/{userId}/playlists/{playlistId}/songs/{songId}
     */
    match /users/{userId}/playlists/{playlistId}/songs/{songId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Stores all songs added by any user, forming a global catalog. Read access is public, but write access is restricted to the song owner.
     * @path /songs/{songId}
     */
    match /songs/{songId} {
        function isOwner() {
            return request.auth != null && request.auth.uid == resource.data.ownerId;
        }

        allow get: if true;
        allow list: if true;
        allow create: if request.auth != null && request.resource.data.ownerId == request.auth.uid; // CRITICAL: Ensure song documents have an ownerId field that matches the user's UID on creation.
        allow update: if request.auth != null && request.resource.data.ownerId == request.auth.uid; // Only the owner can update.
        allow delete: if request.auth != null && request.resource.data.ownerId == request.auth.uid; // Only the owner can delete.
    }

    /**
     * @description Secures chat messages for a specific song.
     * @path /songs/{songId}/messages/{messageId}
     */
    match /songs/{songId}/messages/{messageId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls who can view a user's followers.
     * @path /users/{userId}/followers/{followerId}
     */
     match /users/{userId}/followers/{followerId} {
       function isOwner(userId) {
         return request.auth != null && request.auth.uid == userId;
       }

       allow get: if isOwner(userId);
       allow list: if false;
       allow create: if false;
       allow update: if false;
       allow delete: if false;
     }

     /**
      * @description Controls who can view a user's followings.
      * @path /users/{userId}/following/{followingId}
      */
     match /users/{userId}/following/{followingId} {
       function isOwner(userId) {
         return request.auth != null && request.auth.uid == userId;
       }

       allow get: if isOwner(userId);
       allow list: if false;
       allow create: if false;
       allow update: if false;
       allow delete: if false;
     }

     /**
      * @description Manages access to private chat rooms between users. Only participants can access.
      * @path /chats/{chatId}
      */
     match /chats/{chatId} {
       function isSignedIn() {
         return request.auth != null;
       }

       function isParticipant() {
         return request.auth != null && request.resource.data.participantIds.hasAny([request.auth.uid]);
       }

        function isExistingParticipant() {
            return request.auth != null && resource.data.participantIds.hasAny([request.auth.uid]);
        }

       allow get: if isExistingParticipant();
       allow list: if false;
       allow create: if isSignedIn() && request.resource.data.participantIds.hasAny([request.auth.uid]);
       allow update: if isExistingParticipant();
       allow delete: if isExistingParticipant();
     }

     /**
      * @description Secures messages within a private chat room. Only participants can manage messages.
      * @path /chats/{chatId}/messages/{messageId}
      */
     match /chats/{chatId}/messages/{messageId} {
       function isChatParticipant(chatId) {
           return get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]);
       }

       function isSignedIn() {
         return request.auth != null;
       }

       allow get: if isSignedIn() && isChatParticipant(chatId);
       allow list: if isSignedIn() && isChatParticipant(chatId);
       allow create: if isSignedIn() && isChatParticipant(chatId);
       allow update: if false;
       allow delete: if false;
     }
  }
}