/**
 * @fileoverview Firestore Security Rules for the Aura application.
 *
 * Core Philosophy:
 * This ruleset prioritizes user data protection and access control. It uses a combination of ownership-based and shared-access security models.
 *
 * Data Structure:
 * - Users: /users/{userId} - User profiles, accessible for read by everyone, writeable only by the user themselves.
 * - Playlists: /users/{userId}/playlists/{playlistId} - Playlists owned by a user. Readable by everyone, writeable only by the owner.
 * - Songs (in playlists): /users/{userId}/playlists/{playlistId}/songs/{songId} - Songs within a playlist. Only accessible by the owner of the playlist.
 * - Global Song Catalog: /songs/{songId} - Publicly readable and writable song catalog.
 * - Song Messages: /songs/{songId}/messages/{messageId} - Publicly readable and writeable messages (chat) for each song.
 * - Followers: /users/{userId}/followers/{followerId} - List of followers for a user. Readable by everyone. Creation only allowed by the follower, and deletion allowed by either the user or the follower.
 * - Following: /users/{userId}/following/{followingId} - List of users a user is following. Readable by everyone, writable only by the owner.
 * - Chats: /chats/{chatId} - Private chat sessions between users. Listable only with a `where` clause on `participantIds` using `array-contains`.
 * - Chat Messages: /chats/{chatId}/messages/{messageId} - Messages within a private chat. Only accessible by chat participants.
 *
 * Key Security Decisions:
 * - Public Profile Reading: User profiles are publicly readable to facilitate discovery.
 * - Owner-Only Playlist Management: Playlists and their contents are strictly controlled by the playlist owner.
 * - Public Song Catalog: The song catalog is open for reading and writing to allow for community contributions.
 * - Open Song Chat: Chat messages for songs are publicly accessible, promoting discussion.
 * - Secure Chat Listing: Listing of all chats is strictly forbidden. Chats must be queried by participant.
 *
 * Denormalization for Authorization:
 *  - The `userId` field on the `Playlist` entity allows rules to quickly check ownership without additional `get()` calls.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profiles.
     * @path /users/{userId}
     * @allow (get, list): Any signed-in user can read any user's profile.
     * @allow (create, update, delete): Only the user with the matching {userId} can modify their own profile.
     * @deny: Any attempt to create, update, or delete another user's profile.
     * @principle: Enforces user-ownership for writes. Public read access for profiles.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if isSignedIn();
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Controls access to user playlists.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (get, list): Any signed-in user can read any user's playlists.
     * @allow (create, update, delete): Only the user with the matching {userId} can modify their own playlists.
     * @deny: Any attempt to create, update, or delete another user's playlist.
     * @principle: Enforces user-ownership for writes. Public read access for playlists.
     */
    match /users/{userId}/playlists/{playlistId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if isSignedIn();
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Controls access to songs within a user's playlist.
     * @path /users/{userId}/playlists/{playlistId}/songs/{songId}
     * @allow (get, list, create, update, delete): Only the user with the matching {userId} can modify their own playlist songs.
     * @deny: Any attempt to create, update, or delete another user's playlist songs.
     * @principle: Enforces strict user-ownership for all operations.
     */
    match /users/{userId}/playlists/{playlistId}/songs/{songId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
        function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to the global song catalog.
     * @path /songs/{songId}
     * @allow (get, list, create, update, delete): All signed-in users can read and write to the global song catalog.
     * @principle: Open access for all signed-in users.
     */
    match /songs/{songId} {
      function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isSignedIn();
    }

    /**
     * @description Controls access to chat messages for a song.
     * @path /songs/{songId}/messages/{messageId}
     * @allow (get, list, create): All signed-in users can read and create messages for a song.
     * @allow (update, delete): All signed-in users can update and delete messages for a song.
     * @principle: Open access for all signed-in users.
     */
    match /songs/{songId}/messages/{messageId} {
      function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isSignedIn();
    }

    /**
     * @description Controls access to a user's list of followers.
     * @path /users/{userId}/followers/{followerId}
     * @allow (get, list): Any signed-in user can read the list of followers for any user.
     * @allow (create): Only the follower can create a follow relationship on their own behalf.
     * @allow (delete): Either the user being followed or the follower can delete the relationship.
     * @deny: Any attempt to create a follow relationship on behalf of another user.
     * @principle: Public read access. User-controlled "follow" relationships.
     */
    match /users/{userId}/followers/{followerId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isSelfFollowing(followerId) {
        return request.auth != null && request.auth.uid == followerId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if isSignedIn();
      allow create: if isSignedIn() && isSelfFollowing(followerId);
      allow delete: if isSignedIn() && (isOwner(userId) || isSelfFollowing(followerId));
    }

    /**
     * @description Controls access to the list of users a user is following.
     * @path /users/{userId}/following/{followingId}
     * @allow (get, list): Any signed-in user can read who a user is following.
     * @allow (create, delete): Only the user with the matching {userId} can modify their own "following" list.
     * @deny: Any attempt to modify another user's "following" list.
     * @principle: Public read access. User-ownership for writes.
     */
    match /users/{userId}/following/{followingId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if isSignedIn();
      allow create: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to private chat sessions between users.
     * @path /chats/{chatId}
     * @allow list: Only if the client uses a 'where' query on 'participantIds' with 'array-contains' and THEIR OWN UID.
     * @principle: Restricts listing to secure queries only. Prevents collection-wide listing.
     */
    match /chats/{chatId} {
       function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isSignedIn();
      allow list: if isSignedIn() && request.query.size() == 1 && request.query.where("participantIds", "array-contains", request.auth.uid).size() == 1;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to messages within a private chat.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get, list): Only participants of the chat can read the messages.
     * @allow (create): Only participants can create messages, and only on their own behalf.
     * @allow (update, delete): Only the sender of the message can update or delete it.
     * @principle: Restricts access to chat participants. Enforces message ownership.
     */
    match /chats/{chatId}/messages/{messageId} {
      function isChatParticipant(chatId) {
        return request.auth != null && get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]);
      }
      function isMessageSender(messageId, chatId) {
          return request.auth != null && get(/databases/$(database)/documents/chats/$(chatId)/messages/$(messageId)).data.senderUid == request.auth.uid;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if isSignedIn() && isChatParticipant(chatId);
      allow create: if isSignedIn() && isChatParticipant(chatId);
      allow update: if isSignedIn() && isMessageSender(messageId, chatId);
      allow delete: if isSignedIn() && isMessageSender(messageId, chatId);
    }
  }
}