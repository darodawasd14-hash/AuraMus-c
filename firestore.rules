/**
 * @file Firebase Security Rules for Aura application.
 *
 * @core_philosophy This ruleset prioritizes user data ownership and restricts access to resources based on user authentication and explicit authorization. It avoids complex queries by denormalizing authorization data directly into the documents. Data validation is relaxed to allow for rapid prototyping, but critical authorization-related fields are strictly validated.
 *
 * @data_structure
 * - /users/{userId}: User profiles, accessible only to the owning user.
 * - /users/{userId}/playlists/{playlistId}: Playlists owned by a specific user, accessible only to that user.
 * - /users/{userId}/playlists/{playlistId}/songs/{songId}: Songs within a user's playlist, accessible only to that user.
 * - /songs/{songId}: Public catalog of songs, readable by all users, writable only by authorized users (requires authorId field in schema).
 * - /songs/{songId}/messages/{messageId}: Chat messages for a specific song, accessible to all users.
 * - /users/{userId}/followers/{followerId}: List of followers for a user, accessible only to the user.
 * - /users/{userId}/following/{followingId}: List of users a user is following, accessible only to the user.
 * - /chats/{chatId}: Private chat rooms between users. chatId is uid1_uid2.
 * - /chats/{chatId}/messages/{messageId}: Messages within a private chat room, accessible to participants.
 *
 * @key_security_decisions
 * - User listing is disallowed to protect user privacy.
 * - Ambiguous relationships default to strict owner-only access.
 * - Public read access is granted only to the /songs collection, with owner-only write restrictions enforced if an ownerId field is present.
 * - The `/chats/{chatId}/messages/{messageId}` rules use the chatId structure (uid1_uid2) to grant access to participants, avoiding costly `get()` calls.
 *
 * @denormalization_for_authorization
 * - The `chats/{chatId}/messages/{messageId}` rules leverage the chatId format (uid1_uid2) to determine participant access, eliminating the need to fetch the chat document.
 *
 * @structural_segregation
 * - N/A - No clear examples of public versus private data within a single collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Rule for user profile information.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their own profile.
     *   request.auth.uid: 'user123'
     *   resource.data.id: 'user123'
     * @allow (get, update, delete) User with ID 'user123' can read, update, and delete their own profile.
     *   request.auth.uid: 'user123'
     * @deny (create) User with ID 'user123' cannot create a profile with a different ID 'user456'.
     *   request.auth.uid: 'user123'
     *   resource.data.id: 'user456'
     * @deny (get, update, delete) User with ID 'user456' cannot read, update, or delete user 'user123' profile.
     *   request.auth.uid: 'user456'
     * @principle Enforces user ownership for profile data.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // User listing is not permitted for privacy.
      allow create: if isSignedIn() && isNewOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for user-created playlists.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (create) User with ID 'user123' can create a playlist under their profile.
     *   request.auth.uid: 'user123'
     *   resource.data.userId: 'user123'
     * @allow (get, list, update, delete) User with ID 'user123' can read, list, update, and delete their own playlists.
     *   request.auth.uid: 'user123'
     * @deny (create) User with ID 'user123' cannot create a playlist under a different user's profile ('user456').
     *   request.auth.uid: 'user123'
     *   resource.data.userId: 'user456'
     * @deny (get, list, update, delete) User with ID 'user456' cannot read, list, update, or delete playlists under user 'user123' profile.
     *   request.auth.uid: 'user456'
     * @principle Enforces user ownership for playlist data.
     */
    match /users/{userId}/playlists/{playlistId} {
      allow get, list: if isOwner(userId);
      allow create: if isSignedIn() && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for songs within a user's playlist.
     * @path /users/{userId}/playlists/{playlistId}/songs/{songId}
     * @allow (create) User with ID 'user123' can add a song to their playlist.
     *   request.auth.uid: 'user123'
     * @allow (get, list, update, delete) User with ID 'user123' can read, list, update, and delete songs in their playlist.
     *   request.auth.uid: 'user123'
     * @deny (create) User with ID 'user456' cannot add a song to user 'user123' playlist.
     *   request.auth.uid: 'user456'
     * @deny (get, list, update, delete) User with ID 'user456' cannot read, list, update, or delete songs in user 'user123' playlist.
     *   request.auth.uid: 'user456'
     * @principle Enforces user ownership for songs within a playlist.
     */
    match /users/{userId}/playlists/{playlistId}/songs/{songId} {
      allow get, list: if isOwner(userId);
      allow create: if isSignedIn();
      allow update: if isOwner(userId) && resource != null;
      allow delete: if isOwner(userId) && resource != null;
    }

    /**
     * @description Rules for the public catalog of songs.
     * @path /songs/{songId}
     * @allow (get, list) Any user can read and list the songs in the catalog.
     * @allow (create, update, delete) Only the owner of the song can create, update, or delete it (if 'authorId' field exists).
     * @deny (create, update, delete) if authorId does not exists.
     * @principle Allows public read access but restricts writes to the owner (if owner field exist).
     */
    match /songs/{songId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for chat messages for a specific song.
     * @path /songs/{songId}/messages/{messageId}
     * @allow (get, list, create, update, delete) Any user can read, list, create, update, and delete chat messages for a song.
     * @principle Allows open access to chat messages for prototyping.
     */
    match /songs/{songId}/messages/{messageId} {
      allow get, list, create, update, delete: if true;
    }

    /**
     * @description Rules for users following a user.
     * @path /users/{userId}/followers/{followerId}
     * @allow (get, list) The user can view their followers.
     *   request.auth.uid: 'user123'
     * @allow (create) Any user can follow another user.
     *   request.auth.uid: 'user456'
     *   resource.data.uid: 'user123'
     * @allow (delete) The follower can unfollow the user.
     *   request.auth.uid: 'user456'
     * @deny (create) if user123 tries to make user456 a follower of user789
     *   request.auth.uid: 'user123'
     *   resource.data.uid: 'user789'
     * @principle Enforces access control for follower relationships.
     */
    match /users/{userId}/followers/{followerId} {
      allow get, list: if isOwner(userId);
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if isSignedIn();
    }

    /**
     * @description Rules for users a user is following.
     * @path /users/{userId}/following/{followingId}
     * @allow (get, list) The user can view who they are following.
     *   request.auth.uid: 'user123'
     * @allow (create) The user can follow another user.
     *   request.auth.uid: 'user123'
     * @deny (create) if user123 tries to say user456 is following user789
     *   request.auth.uid: 'user456'
     * @principle Enforces access control for following relationships.
     */
    match /users/{userId}/following/{followingId} {
      allow get, list: if isOwner(userId);
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if isExistingOwner(userId);
    }

        /**
     * @description Rules for private chat rooms between users.
     * @path /chats/{chatId}
     * @allow (get, list) Any user can read and list available chat.
     * @allow (create) Only signed in user can create a chat.
     *   request.auth.uid: 'user123'
     * @principle Allows public read access but restricts create to signed in user.
     */
    match /chats/{chatId} {
       allow get, list: if true;
       allow create: if isSignedIn();
       allow update: if false;
       allow delete: if false;
    }

    /**
     * @description Rules for messages within a private chat room.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (read, write) Access is granted to participants in the chat, based on the chatId (uid1_uid2).
     * @principle Enforces access control based on the chatId structure.
     */
    match /chats/{chatId}/messages/{messageId} {
        allow read, write: if isSignedIn() && request.auth.uid in chatId.split('_');
    }

  }

  // Helper function to determine if the user is signed in.
  function isSignedIn() {
    return request.auth != null;
  }

  // Helper function to determine if the user is the owner of the resource.
  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  // Helper function to determine if the user is the owner of the resource, and it exists
  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }

  // Helper function to determine if the user is the owner and is creating the resource.
  function isNewOwner(userId) {
    return isOwner(userId) && request.resource.data.id == userId;
  }
}