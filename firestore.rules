/**
 * @fileoverview Firestore Security Rules for Aura application.
 *
 * Core Philosophy:
 * This ruleset prioritizes user data ownership and authenticated access.
 * Users have full control over their profile data and playlists. Public read access is granted to song data.
 *
 * Data Structure:
 * - /users/{userId}: User profile information.
 * - /users/{userId}/playlists/{playlistId}: User-created playlists.
 * - /users/{userId}/playlists/{playlistId}/songs/{songId}: Songs within a specific playlist.
 * - /songs/{songId}: A global catalog of songs added by any user.
 * - /songs/{songId}/messages/{messageId}: Chat messages for a specific song.
 * - /users/{userId}/followers/{followerId}: Users following a specific user.
 * - /users/{userId}/following/{followingId}: Users a specific user is following.
 * - /chats/{chatId}: Private chat rooms between users.
 * - /chats/{chatId}/messages/{messageId}: Messages within a chat room.
 *
 * Key Security Decisions:
 * - Users can only read/write their own profile data and playlists.
 * - Song data is publicly readable, but write access is restricted.
 * - Listing of user's playlists, followers and followings is restricted to the user.
 * - Private chats are accessible only to participants.
 *
 * Denormalization for Authorization:
 * - Chats documents have a `participantIds` array to easily check user access.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects user profile information. Only the user can read and write their own profile.
     * @path /users/{userId}
     * @allow (get) Authenticated user can read any user's profile data.
     * @allow (create) Authenticated user can create their own profile.
     * @allow (update) Authenticated user can update their own profile.
     * @allow (delete) Authenticated user can delete their own profile.
     * @deny  (get) Unauthorized user cannot read another user's profile.
     * @deny  (create) Unauthorized user cannot create a profile with a mismatched user ID.
     * @deny  (update) Unauthorized user cannot update another user's profile.
     * @deny  (delete) Unauthorized user cannot delete another user's profile.
     * @principle Enforces document ownership for writes and allows read for signed in user.
     */
    match /users/{userId} {
      allow get: if isSignedIn();
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Protects user playlists. Only the user can read and write their own playlists.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (get) Authenticated user can read their own playlist data.
     * @allow (create) Authenticated user can create a playlist under their user ID.
     * @allow (update) Authenticated user can update their own playlist.
     * @allow (delete) Authenticated user can delete their own playlist.
     * @deny  (get) Unauthorized user cannot read another user's playlist.
     * @deny  (create) Unauthorized user cannot create a playlist under another user's ID.
     * @deny  (update) Unauthorized user cannot update another user's playlist.
     * @deny  (delete) Unauthorized user cannot delete another user's playlist.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/playlists/{playlistId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Protects songs within a user's playlist. Only the user can read and write songs in their own playlist.
     * @path /users/{userId}/playlists/{playlistId}/songs/{songId}
     * @allow (get) Authenticated user can read their own song data within their playlist.
     * @allow (create) Authenticated user can create a song within their own playlist.
     * @allow (update) Authenticated user can update a song within their own playlist.
     * @allow (delete) Authenticated user can delete a song within their own playlist.
     * @deny  (get) Unauthorized user cannot read another user's song.
     * @deny  (create) Unauthorized user cannot create a song under another user's playlist.
     * @deny  (update) Unauthorized user cannot update another user's song.
     * @deny  (delete) Unauthorized user cannot delete another user's song.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/playlists/{playlistId}/songs/{songId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to all songs. Only authenticated users can create songs.
     * @path /songs/{songId}
     * @allow (get) Any user can read song data.
     * @allow (list) Any user can list song data.
     * @allow (create) Authenticated user can create a song.
     * @allow (update) Authenticated user can update a song.
     * @allow (delete) Authenticated user can delete a song.
     * @deny (create) Unauthorized user cannot create a song.
     * @principle Public read, owner-only write access.
     */
    match /songs/{songId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Protects chat messages for songs. Only authenticated users can read and write messages.
     * @path /songs/{songId}/messages/{messageId}
     * @allow (get) Authenticated user can read chat messages.
     * @allow (create) Authenticated user can create a chat message.
     * @allow (update) Authenticated user can update a chat message.
     * @allow (delete) Authenticated user can delete a chat message.
     * @deny (get) Unauthorized user cannot read chat messages.
     * @deny (create) Unauthorized user cannot create a chat message.
     * @principle Authenticated access for reads and writes.
     */
    match /songs/{songId}/messages/{messageId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isSignedIn();
    }

     /**
      * @description Controls access to the followers subcollection for each user.
      * @path /users/{userId}/followers/{followerId}
      * @allow (get) Authenticated user can read their own followers list.
      * @allow (list) Authenticated user can list their own followers.
      * @allow (create) Authenticated user can create a follower entry.
      * @allow (update) Authenticated user can update a follower entry.
      * @allow (delete) Authenticated user can delete a follower entry.
      * @deny (get) Unauthorized user cannot read another user's followers list.
      * @deny (list) Unauthorized user cannot list another user's followers.
      * @principle Enforces user ownership.
      */
    match /users/{userId}/followers/{followerId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.uid == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.uid == resource.data.uid;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to the following subcollection for each user.
     * @path /users/{userId}/following/{followingId}
     * @allow (get) Authenticated user can read their own followings list.
     * @allow (list) Authenticated user can list their own followings.
     * @allow (create) Authenticated user can create a following entry.
     * @allow (update) Authenticated user can update a following entry.
     * @allow (delete) Authenticated user can delete a following entry.
     * @deny (get) Unauthorized user cannot read another user's followings list.
     * @deny (list) Unauthorized user cannot list another user's followings.
     * @principle Enforces user ownership.
     */
    match /users/{userId}/following/{followingId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.uid == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.uid == resource.data.uid;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to private chat rooms.
     * @path /chats/{chatId}
     * @allow (get) User can get a chat if they are a participant.
     * @allow (list) No listing of all chats.
     * @allow (create) User can create a chat if they are a participant.
     * @allow (update) User can update a chat if they are a participant.
     * @allow (delete) User can delete a chat if they are a participant.
     * @deny (create) User cannot create a chat if they are not a participant.
     * @principle Enforces shared access via participantIds array.
     */
    match /chats/{chatId} {
      allow get: if isSignedIn() && request.auth.uid in resource.data.participantIds;
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.participantIds.hasAll([request.auth.uid]);
      allow update: if isSignedIn() && request.auth.uid in resource.data.participantIds;
      allow delete: if isSignedIn() && request.auth.uid in resource.data.participantIds;
    }

    /**
     * @description Controls access to messages within a chat room.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get) User can get a message if they are a participant in the chat.
     * @allow (list) User can list messages if they are a participant in the chat.
     * @allow (create) User can create a message if they are a participant in the chat.
     * @allow (update) User can update a message if they are a participant in the chat.
     * @allow (delete) User can delete a message if they are a participant in the chat.
     * @deny (create) User cannot create a message if they are not a participant in the chat.
     * @principle Enforces shared access via participantIds array in the parent chat document.
     */
    match /chats/{chatId}/messages/{messageId} {
       allow get: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]);
       allow list: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]);
       allow create: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]);
       allow update: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]);
       allow delete: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]);
    }
  }

  /**
   * @description Checks if the request is from an authenticated user.
   * @return {boolean} True if the user is signed in, false otherwise.
   */
  function isSignedIn() {
    return request.auth != null;
  }

  /**
   * @description Checks if the authenticated user is the owner of the resource.
   * @param {string} userId The user ID to compare against the authenticated user's ID.
   * @return {boolean} True if the user is the owner, false otherwise.
   */
  function isOwner(userId) {
    return isSignedIn() && request.auth.uid == userId;
  }

  /**
   * @description Checks if the authenticated user is the owner of the resource and the resource exists.
   * @param {string} userId The user ID to compare against the authenticated user's ID.
   * @return {boolean} True if the user is the owner and the resource exists, false otherwise.
   */
  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }
}