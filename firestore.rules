/**
 * @file Firebase Security Rules for Aura application.
 *
 * @core_philosophy This ruleset enforces a strict user-ownership model for personal data,
 * while allowing public read access to certain global collections. It prioritizes
 * security by default, explicitly denying access where the data model is ambiguous
 * or incomplete.  It is configured for Prototyping mode and relaxes the validation
 * of data shape.
 *
 * @data_structure
 * - /users/{userId}: User profile information. Owner-only access.
 * - /users/{userId}/playlists/{playlistId}: Playlists created by a user. Owner-only access.
 * - /users/{userId}/playlists/{playlistId}/songs/{songId}: Songs within a user's playlist. Owner-only access.
 * - /songs/{songId}: A global catalog of songs, publicly readable but owner-only writable.
 * - /songs/{songId}/messages/{messageId}: Chat messages for a specific song.
 * - /users/{userId}/followers/{followerId}: Users following a given user.
 * - /users/{userId}/following/{followingId}: Users a given user is following.
 * - /chats/{chatId}: Private chat rooms between users.
 * - /chats/{chatId}/messages/{messageId}: Messages within a private chat room.
 *
 * @key_security_decisions
 * - User listing is disallowed.
 * - Public read access is granted to the /songs collection.
 * - Data validation is minimized to focus on authorization in this prototyping phase.
 * - All write operations require a verified user identity.
 *
 * @denormalization_for_authorization
 * - The `userId` field within playlist documents is used to enforce ownership, avoiding the need for additional `get()` calls.
 * - The `participantIds` field in `/chats/{chatId}` is used to authorize access to chat messages.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile information. Only the user can read or write their own profile.
     * @path /users/{userId}
     * @allow (create, update, delete): Authenticated user with matching userId can modify the document.
     * @allow (get, list): Authenticated user with matching userId can read the document.
     * @deny (create, update, delete): Any other user attempting to modify the document.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      // Users can only manage their own profiles
      allow get: if isOwner(userId);
      allow list: if false; // User listing is not permitted

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to playlists created by a user. Only the owning user can manage their playlists.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (create, update, delete): Authenticated user with matching userId can modify the playlist.
     * @allow (get, list): Authenticated user with matching userId can read the playlist.
     * @deny (create, update, delete): Any other user attempting to modify the playlist.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/playlists/{playlistId} {
      // Playlists are user-owned
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to songs within a user's playlist. Only the owning user can manage songs in their playlists.
     * @path /users/{userId}/playlists/{playlistId}/songs/{songId}
     * @allow (create, update, delete): Authenticated user with matching userId can modify the song.
     * @allow (get, list): Authenticated user with matching userId can read the song.
     * @deny (create, update, delete): Any other user attempting to modify the song.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/playlists/{playlistId}/songs/{songId} {
      // Songs within playlists are user-owned
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to the global songs catalog.  Any user can read songs, but only the song's creator can modify it.
     * @path /songs/{songId}
     * @allow (get, list): Any authenticated user can read the song.
     * @allow (create, update, delete): Only the song's creator (owner) can modify the song.
     * @deny (create, update, delete): Any other user attempting to modify the song.
     * @principle Allows public read access while enforcing ownership for write operations.
     */
    match /songs/{songId} {
      // Public read, owner-only write
      allow get: if true;
      allow list: if true;

      allow create: if isSignedIn(); // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Controls access to chat messages for a specific song.
     * @path /songs/{songId}/messages/{messageId}
     */
    match /songs/{songId}/messages/{messageId} {
      // Anyone can create a message
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if false; // No updates
      allow delete: if false; // No deletes
    }
    
    /**
     * @description Controls access to the list of followers for a user.
     * @path /users/{userId}/followers/{followerId}
     */
    match /users/{userId}/followers/{followerId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if false;
      allow delete: if isOwner(userId);
    }
    
    /**
     * @description Controls access to the list of users a user is following.
     * @path /users/{userId}/following/{followingId}
     */
    match /users/{userId}/following/{followingId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if false;
      allow delete: if isOwner(userId);
    }

    /**
     * @description Controls access to private chat rooms between users.
     * @path /chats/{chatId}
     * @allow (read, write): Only participants of the chat can access the chat.
     * @deny (read, write): Users who are not participants of the chat.
     * @principle Enforces shared access control for collaborative documents.
     */
    match /chats/{chatId} {
      allow get: if isSignedIn() && request.auth.uid in resource.data.participantIds;
      allow list: if false; // Listing all chats is not allowed

      allow create: if isSignedIn() && request.resource.data.participantIds.hasAll([request.auth.uid]);
      allow update: if isSignedIn() && request.auth.uid in resource.data.participantIds;
      allow delete: if false; // Deletion not allowed
    }

    /**
     * @description Controls access to messages within a private chat room.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (read, write): Only participants of the chat can access messages in the chat.
     * @deny (read, write): Users who are not participants of the chat.
     * @principle Enforces shared access control for collaborative documents.
     */
    match /chats/{chatId}/messages/{messageId} {
      allow get: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]);
      allow list: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]);

      allow create: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]);
      allow update: if false; // No updates
      allow delete: if false; // No deletes
    }
  }

  // Helper functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return isSignedIn() && request.auth.uid == userId;
  }

  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }
}