/**
 * @file Firestore Security Rules
 * @core_philosophy This ruleset enforces a strict user-ownership model for personal data (users, playlists, songs under playlists, followers, following).
 *  Global collections (songs, chats) have public read access with owner-only write access.
 *  Shared access via "participantIds" arrays is used for /chats and their subcollections.
 * @data_structure
 *  /users/{userId}: User profile information.
 *  /users/{userId}/playlists/{playlistId}: User-created playlists.
 *  /users/{userId}/playlists/{playlistId}/songs/{songId}: Songs within a playlist.
 *  /songs/{songId}: Global catalog of songs.
 *  /songs/{songId}/messages/{messageId}: Chat messages for a song.
 *  /users/{userId}/followers/{followerId}: Users following a user.
 *  /users/{userId}/following/{followingId}: Users a user is following.
 *  /chats/{chatId}: Private chat rooms between users.
 *  /chats/{chatId}/messages/{messageId}: Messages within a chat room.
 * @key_security_decisions
 *  - Users can only read/write their own profile data.
 *  - Users can only manage (create/update/delete) their own playlists and songs within those playlists.
 *  - Global song catalog is publicly readable, but only owners can modify songs.
 *  - Followers/Following are user-managed; only the user can modify their own lists.
 *  - Chats are shared resources; access is controlled via the "participantIds" array.
 *  - Listing of users is disallowed.
 * @denormalization_for_authorization
 *  - Chat documents contain a "participantIds" array to simplify authorization checks.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (get) Authenticated user can read their own profile.
     * @allow (create) Authenticated user can create their own profile if the userId matches their auth UID.
     * @allow (update) Authenticated user can update their own profile if the userId matches their auth UID and the document exists.
     * @allow (delete) Authenticated user can delete their own profile if the userId matches their auth UID and the document exists.
     * @deny (list) Listing users is not allowed.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      
      function isExistingOwner(userId) {
        return isOwner(userId) && exists(resource);
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to user playlists.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (get) Authenticated user can read their own playlist.
     * @allow (create) Authenticated user can create a playlist under their user ID.
     * @allow (update) Authenticated user can update their own playlist if the document exists.
     * @allow (delete) Authenticated user can delete their own playlist if the document exists.
     * @deny Request from a different user.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/playlists/{playlistId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && exists(resource);
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to songs within a user's playlist.
     * @path /users/{userId}/playlists/{playlistId}/songs/{songId}
     * @allow (get) Authenticated user can read their own playlist song.
     * @allow (create) Authenticated user can create a playlist song under their user ID and playlist.
     * @allow (update) Authenticated user can update their own playlist song if the document exists.
     * @allow (delete) Authenticated user can delete their own playlist song if the document exists.
     * @deny Request from a different user.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/playlists/{playlistId}/songs/{songId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && exists(resource);
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to the global song catalog.
     * @path /songs/{songId}
     * @allow (get, list) Public read access to the song catalog.
     * @allow (create) Authenticated user can add a song to the catalog, validating ownership field.
     * @allow (update) Only the song's owner can update it, and the document must exist.
     * @allow (delete) Only the song's owner can delete it, and the document must exist.
     * @principle Public read, owner-only writes.
     */
    match /songs/{songId} {
      allow get: if true;
      allow list: if true;
      // CRITICAL: Cannot implement owner-only writes. The 'Song' entity is missing an 'ownerId' or 'authorId' field.
      allow create: if true; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false;
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Controls access to chat messages for a song.
     * @path /songs/{songId}/messages/{messageId}
     * @allow (get, list) Public read access to messages for a song.
     * @allow (create) Authenticated user can create a message.
     * @allow (update) No updates allowed.
     * @allow (delete) Only the message creator can delete it, and the document must exist.
     * @principle Public read, owner-only delete.
     */
    match /songs/{songId}/messages/{messageId} {
        function isSignedIn() {
          return request.auth != null;
        }

        function isOwner() {
            return request.auth.uid == resource.data.sender.uid;
        }

        function isExistingOwner() {
          return isOwner() && exists(resource);
        }

        allow get, list: if true;
        allow create: if isSignedIn();
        allow update: if false;
        allow delete: if isExistingOwner();
    }

    /**
     * @description Controls access to a user's followers.
     * @path /users/{userId}/followers/{followerId}
     * @allow (get) Authenticated user can read their own followers.
     * @allow (create) Authenticated user can add a follower to their list.
     * @allow (update) Not allowed
     * @allow (delete) Authenticated user can remove a follower from their list.
     * @deny Request from a different user.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/followers/{followerId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && exists(resource);
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if false;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to a user's following list.
     * @path /users/{userId}/following/{followingId}
     * @allow (get) Authenticated user can read who they are following.
     * @allow (create) Authenticated user can add to their following list.
     * @allow (update) Not allowed
     * @allow (delete) Authenticated user can remove from their following list.
     * @deny Request from a different user.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/following/{followingId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && exists(resource);
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if false;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to private chat rooms between users.
     * @path /chats/{chatId}
     * @allow (get) User can read the chat if they are a participant.
     * @allow (create) User can create a chat if they are a participant.
     * @allow (update) Only participants can update the chat, and the document must exist. Only `lastMessage` and `lastMessageTimestamp` are mutable.
     * @allow (delete) Not allowed. Chats should not be deleted.
     * @deny Request if the user is not a participant.
     * @principle Shared access via "participantIds" array.
     */
    match /chats/{chatId} {
      function isSignedIn() {
          return request.auth != null;
      }
      
      function isParticipant() {
          return isSignedIn() && request.auth.uid in resource.data.participantIds;
      }

      function isExistingParticipant() {
          return isParticipant() && exists(resource);
      }
      
      allow get: if isParticipant();
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.participantIds.hasAny([request.auth.uid]);
      allow update: if isExistingParticipant();
      allow delete: if false;
    }

    /**
     * @description Controls access to messages within a private chat room.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get, list) User can read messages if they are a participant in the chat.
     * @allow (create) User can create a message if they are a participant in the chat.
     * @allow (update) Not allowed. Messages are immutable.
     * @allow (delete) Only the message creator can delete it, and the document must exist.
     * @deny Request if the user is not a participant.
     * @principle Shared access via "participantIds" array, owner-only delete for messages.
     */
    match /chats/{chatId}/messages/{messageId} {
      function isSignedIn() {
          return request.auth != null;
      }

      function isParticipant() {
          return isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]);
      }
      
      function isOwner() {
        return request.auth.uid == resource.data.sender.uid;
      }
      
      function isExistingOwner() {
        return isOwner() && exists(resource);
      }

      allow get, list: if isParticipant();
      allow create: if isParticipant();
      allow update: if false;
      allow delete: if isExistingOwner();
    }
  }
}