/**
 * @fileOverview Firestore Security Rules for Aura application.
 *
 * Core Philosophy:
 * This ruleset enforces a user-centric security model with ownership-based access control for user profiles, playlists, and songs.
 * Private chats are secured using a shared access pattern, where only participants can read and write messages.
 * Public read access is granted to the global song catalog.
 *
 * Data Structure:
 * - /users/{userId}: User profiles, accessible only by the user themselves.
 * - /users/{userId}/playlists/{playlistId}: User-specific playlists, accessible only by the user.
 * - /users/{userId}/playlists/{playlistId}/songs/{songId}: Songs within a user's playlist, accessible only by the user.
 * - /songs/{songId}: A global catalog of songs, publicly readable but writable only with valid ownership.
 * - /songs/{songId}/messages/{messageId}: Chat messages for a specific song, accessible to all.
 * - /users/{userId}/followers/{followerId}: Follower relationships, accessible only by the user.
 * - /users/{userId}/following/{followingId}: Following relationships, accessible only by the user.
 * - /chats/{chatId}: Private chat rooms between users, accessible only to participants.
 * - /chats/{chatId}/messages/{messageId}: Messages within a private chat room, accessible only to participants.
 *
 * Key Security Decisions:
 * - Users can only manage their own data (profiles, playlists, songs within playlists).
 * - The global song catalog is publicly readable, but write access is restricted to owners.
 * - Private chats require both users to be participants in the chat and follow each other.
 * - Listing of followers/following is allowed only for the user themselves.
 * - Data validation is relaxed to facilitate rapid prototyping, focusing on authorization and relational integrity.
 *
 * Denormalization for Authorization:
 * - Chat documents contain a `participantIds` array to enable efficient access control for chat messages.
 *
 * Structural Segregation:
 * - Drafts and published content are not explicitly separated, but the global song catalog serves as a form of public content.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Rule for user profile information.
     * @path /users/{userId}
     * @allow (create) - User can create their own profile.
     * @allow (get, update, delete) - User can read, update, and delete their own profile.
     * @deny (create, update, delete) - User cannot create, update, or delete another user's profile.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
      allow get: if isOwner(userId);
      allow list: if false; // User listing is generally disabled for privacy

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule for user-created playlists.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (create, get, update, delete) - User can manage their own playlists.
     * @deny (create, get, update, delete) - User cannot manage another user's playlists.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/playlists/{playlistId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
      allow get: if isOwner(userId);
      allow list: if false;

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule for songs within a user's playlist.
     * @path /users/{userId}/playlists/{playlistId}/songs/{songId}
     * @allow (create, get, update, delete) - User can manage songs in their playlists.
     * @deny (create, get, update, delete) - User cannot manage songs in another user's playlists.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/playlists/{playlistId}/songs/{songId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
      allow get: if isOwner(userId);
      allow list: if false;

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule for the global song catalog.
     * @path /songs/{songId}
     * @allow (get, list) - All users can read the song catalog.
     * @allow (create, update, delete) - Only the song owner can modify the song. Requires 'ownerId' field in the document.
     * @deny (create, update, delete) - Users cannot modify songs they don't own.
     * @principle Allows public read access with owner-only writes.
     */
    match /songs/{songId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(ownerId) {
          return isSignedIn() && request.auth.uid == resource.data.ownerId;
      }
       allow get: if true;
       allow list: if true;

      allow create: if isSignedIn();
      allow update: if isOwner(songId);
      allow delete: if isOwner(songId);
    }

    /**
     * @description Rule for chat messages for a specific song.
     * @path /songs/{songId}/messages/{messageId}
     * @allow (create, get, list) - All users can read and create chat messages.
     * @deny (update, delete) - Users cannot update or delete chat messages.
     */
    match /songs/{songId}/messages/{messageId} {
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update, delete: if false;
    }
     /**
      * @description Rule for the followers of a user.
      * @path /users/{userId}/followers/{followerId}
      * @allow (get, list) - Only the user can list their followers.
      * @allow (create, delete) - Only the user can add or remove followers (self-follow).
      * @deny (create, delete) - Users cannot add or remove followers for other users.
      * @principle Enforces document ownership for writes.
      */
    match /users/{userId}/followers/{followerId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
      allow get: if isOwner(userId);
      allow list: if false;

      allow create: if isOwner(userId) && request.auth.uid == followerId;
      allow delete: if isExistingOwner(userId) && request.auth.uid == followerId;
    }

    /**
     * @description Rule for the users that a user is following.
     * @path /users/{userId}/following/{followingId}
     * @allow (get, list) - Only the user can list who they are following.
     * @allow (create, delete) - Only the user can add or remove users they are following.
     * @deny (create, delete) - Users cannot add or remove users that other users are following.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/following/{followingId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
      allow get: if isOwner(userId);
      allow list: if false;

      allow create: if isOwner(userId) && request.auth.uid == userId;
      allow delete: if isExistingOwner(userId) && request.auth.uid == userId;
    }
    /**
     * @description Rule for private chat rooms between users.
     * @path /chats/{chatId}
     * @allow (get, list) - Only participants can view the chat room.
     * @allow (create) - Only users who both follow each other can create a chat room.
     * @deny (update, delete) - Users cannot update or delete chat rooms.
     * @principle Enforces shared access for collaborative documents.
     */
    match /chats/{chatId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant(chatId) {
          return isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]);
      }
      allow get, list: if isParticipant(chatId);
      allow create: if isSignedIn() && request.resource.data.participantIds.hasAny([request.auth.uid]);
      allow update, delete: if false;
    }

    /**
     * @description Rule for messages within a private chat room.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get, list, create) - Only participants can view and create messages.
     * @deny (update, delete) - Users cannot update or delete messages.
     * @principle Enforces shared access for collaborative documents.
     */
    match /chats/{chatId}/messages/{messageId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isParticipant(chatId) {
        return isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]);
      }
      allow get, list, create: if isParticipant(chatId);
      allow update, delete: if false;
    }
  }
}