/**
 * @file firestore.rules
 * @description This ruleset enforces a security model that prioritizes user data ownership and public readability where appropriate,
 *              while remaining permissive on data shapes for prototyping. It grants authenticated users access to read user profiles
 *              and manage their own data, while also allowing them to follow and be followed by other users. Public song data can
 *              be read by anyone, but modifications are restricted until proper owner validation can be implemented.
 *
 * @dataStructure
 *  - /users/{userId}: Stores user profiles. Allows read access to any authenticated user, write access only to the owner.
 *  - /users/{userId}/playlists/{playlistId}: Stores playlists owned by a specific user. Only the owner can manage these playlists.
 *  - /users/{userId}/playlists/{playlistId}/songs/{songId}: Stores songs within a specific playlist. Only the playlist owner can manage these songs.
 *  - /songs/{songId}: Stores publicly available songs. Read access is public, but write access is restricted. Requires an `ownerId` field to enable secure write rules.
 *  - /songs/{songId}/messages/{messageId}: Stores chat messages associated with a song. Any authenticated user can create messages, but other operations are restricted.
 *  - /users/{userId}/followers/{followerId}: List of users who follow {userId}. Any authenticated user can read the list of followers. Creating and deleting followers must be implemented.
 *  - /users/{userId}/following/{followingId}: List of users that {userId} is following. Any authenticated user can read the list of followed users. Creating and deleting followed users must be implemented.
 *
 * @keySecurityDecisions
 *  - User listing is implicitly disallowed (no top-level `/users` collection).
 *  - Public song data is read-only for now, write access will be secured by owner validation once the `ownerId` field is added to the schema.
 *  - Ambiguous relationships default to strict owner-only access.
 *  - The ruleset uses flexible data validation to allow for rapid prototyping and iteration on data shapes.
 *
 * @denormalizationForAuthorization
 *  - User IDs are used in document paths to enforce ownership, avoiding the need for `get()` calls to determine ownership.
 *  - No role-based access control is used in this initial version.
 *
 * @structuralSegregation
 *  - Public and private data are stored in separate collections where appropriate (e.g., user-owned playlists under `/users/{userId}` and public songs under `/songs`).
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages user profile data. Allows authenticated users to read any profile, and only the owner to update their own profile.
     * @path /users/{userId}
     * @allow (read) User A with UID 'userA' can read User B's profile.
     * @allow (write) User A with UID 'userA' can update their own profile.
     * @deny (write) User A with UID 'userA' cannot update User B's profile.
     * @principle Enforces document ownership for writes, allows public reads for authenticated users.
     */
    match /users/{userId} {
      allow get: if isSignedIn();
      allow list: if false;
      allow create: if request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages playlists owned by a specific user. Only the owner can create, read, update, or delete their own playlists.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (create) User A with UID 'userA' can create a playlist under their own user ID.
     * @allow (get) User A with UID 'userA' can read a playlist under their own user ID.
     * @allow (update) User A with UID 'userA' can update a playlist under their own user ID.
     * @allow (delete) User A with UID 'userA' can delete a playlist under their own user ID.
     * @deny (create) User A with UID 'userA' cannot create a playlist under User B's user ID.
     * @principle Enforces strict document ownership for all operations.
     */
    match /users/{userId}/playlists/{playlistId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages songs within a specific playlist. Only the playlist owner can manage the songs in their playlist.
     * @path /users/{userId}/playlists/{playlistId}/songs/{songId}
     * @allow (create) User A with UID 'userA' can create a song in their own playlist.
     * @allow (get) User A with UID 'userA' can read a song in their own playlist.
     * @allow (update) User A with UID 'userA' can update a song in their own playlist.
     * @allow (delete) User A with UID 'userA' can delete a song in their own playlist.
     * @deny (create) User A with UID 'userA' cannot create a song in User B's playlist.
     * @principle Enforces strict document ownership for all operations.
     */
    match /users/{userId}/playlists/{playlistId}/songs/{songId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages publicly available songs. Read access is public, but write access is restricted until proper owner validation is implemented.
     * @path /songs/{songId}
     * @allow (get) Any user can read any song.
     * @allow (list) Any user can list songs.
     * @deny (create) No user can create a song until owner validation is implemented.
     * @deny (update) No user can update a song until owner validation is implemented.
     * @deny (delete) No user can delete a song until owner validation is implemented.
     * @principle Allows public reads, restricts writes pending schema update and owner validation.
     */
    match /songs/{songId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Manages chat messages associated with a song. Any authenticated user can create messages, but other operations are restricted.
     * @path /songs/{songId}/messages/{messageId}
     * @allow (create) Any authenticated user can create a message.
     * @deny (get) No user can get a message.
     * @deny (list) No user can list messages.
     * @deny (update) No user can update a message.
     * @deny (delete) No user can delete a message.
     * @principle Allows authenticated users to create messages, restricts other operations.
     */
    match /songs/{songId}/messages/{messageId} {
      allow get: if false;
      allow list: if false;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages the list of users who are following a specific user.
     * @path /users/{userId}/followers/{followerId}
     * @allow (read) Any authenticated user can read the list of followers.
     * @deny (create) No user can create a follower relationship until the rule is implemented.
     * @deny (update) No user can update a follower relationship.
     * @deny (delete) No user can delete a follower relationship until the rule is implemented.
     * @principle Allows public reads of followers, requires implementation for writes.
     */
    match /users/{userId}/followers/{followerId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if false; // TODO: Implement follow functionality with appropriate authorization checks.
      allow update: if false;
      allow delete: if false; // TODO: Implement unfollow functionality with appropriate authorization checks.
    }

    /**
     * @description Manages the list of users that a specific user is following.
     * @path /users/{userId}/following/{followingId}
     * @allow (read) Any authenticated user can read the list of followed users.
     * @deny (create) No user can create a following relationship until the rule is implemented.
     * @deny (update) No user can update a following relationship.
     * @deny (delete) No user can delete a following relationship until the rule is implemented.
     * @principle Allows public reads of followed users, requires implementation for writes.
     */
    match /users/{userId}/following/{followingId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if false; // TODO: Implement follow functionality with appropriate authorization checks.
      allow update: if false;
      allow delete: if false; // TODO: Implement unfollow functionality with appropriate authorization checks.
    }
  }

  /**
   * @description Checks if the user is signed in.
   * @return True if the user is signed in, false otherwise.
   */
  function isSignedIn() {
    return request.auth != null;
  }

  /**
   * @description Checks if the request is made by the owner of the document.
   * @param {string} userId The user ID of the document owner.
   * @return True if the request is made by the owner, false otherwise.
   */
  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  /**
   * @description Checks if the request is made by the owner of the document and the document exists.
   * @param {string} userId The user ID of the document owner.
   * @return True if the request is made by the owner and the document exists, false otherwise.
   */
  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }
}